{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Getting started","text":""},{"location":"#what-is-vectorbt","title":"What is vectorbt?","text":"<p>vectorbt is a Python package for quantitative analysis that takes a novel approach to backtesting:  it operates entirely on pandas and NumPy objects, and is accelerated by Numba  to analyze any data at speed and scale. This allows for testing of many thousands of strategies in seconds.</p> <p>In contrast to other backtesters, vectorbt represents complex data as (structured) NumPy arrays. This enables superfast computation using vectorized operations with NumPy and non-vectorized but dynamically  compiled operations with Numba. It also integrates Plotly and  Jupyter Widgets to display complex charts and dashboards akin  to Tableau right in the Jupyter notebook. Due to high performance, vectorbt can process large amounts of  data even without GPU and parallelization and enables the user to interact with data-hungry widgets  without significant delays.</p> <p>With vectorbt, you can</p> <ul> <li> <p> </p> <p>Backtest strategies in a couple of lines of Python code</p> </li> <li> <p> </p> <p>Enjoy the best of both worlds: the ecosystem of Python and the speed of C</p> </li> <li> <p> </p> <p>Retain full control over execution and your data (as opposed to web-based services such as TradingView)</p> </li> <li> <p> </p> <p>Optimize your trading strategy against many parameters, assets, and periods in one go</p> </li> <li> <p> </p> <p>Uncover hidden patterns in financial markets</p> </li> <li> <p> </p> <p>Analyze time series and engineer new features for ML models</p> </li> <li> <p> </p> <p>Supercharge pandas and your favorite tools to run much faster</p> </li> <li> <p> </p> <p>Visualize strategy performance using interactive charts and dashboards (both in Jupyter and browser)</p> </li> <li> <p> </p> <p>Fetch and process data periodically, send Telegram notifications, and more</p> </li> <li> <p></p> <p>Support us to get access to parallelization, portfolio optimization,  pattern recognition, event projections, limit orders, leverage, and 100+ other hot features!</p> </li> </ul>"},{"location":"#why-vectorbt","title":"Why vectorbt?","text":"<p>While there are many great backtesting packages for Python, vectorbt combines an extremely fast  backtester and a data science tool: it excels at processing performance and offers interactive tools  to explore complex phenomena in trading. With it, you can traverse a huge number of strategy  configurations, time periods, and instruments in little time, to explore where your strategy  performs best and to uncover hidden patterns in data. Accessing and analyzing this information  for yourself could give you an information advantage in your own trading.</p>"},{"location":"#how-it-works","title":"How it works","text":"<p>vectorbt was implemented to address common performance shortcomings of backtesting libraries.  It builds upon the idea that each instance of a trading strategy can be represented in a vectorized form,  so multiple strategy instances can be packed into a single multi-dimensional array, processed in a  highly efficient manner, and compared easily. It overhauls the traditional OOP approach that represents  strategies as classes and other data structures, which are easier to write and extend compared to vectors,  but harder to analyze and also require additional effort to do it quickly.</p> <p>Thanks to the time-series nature of trading data, most of the aspects related to backtesting can be  translated into vectors. Instead of processing one element at a time, vectorization allows us to avoid  naive looping and perform the same operation on all elements at the same time. The path-dependency  problem related to vectorization is solved by using Numba - it allows both writing iterative code  and compiling slow Python loops to be run at the native machine code speed.</p>"},{"location":"#example","title":"Example","text":"<p>Let's say we have a complex strategy that has lots of (hyper-)parameters that have to be tuned. While brute-forcing all combinations seems to be a rather unrealistic attempt, we can still interpolate, and vectorbt makes exactly this possible. It doesn't care whether we have one strategy instance or millions. As soon as their vectors can be concatenated into a matrix and we have enough memory, we can analyze them in one go.</p> <p>Let's start with fetching the daily price of Bitcoin:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from datetime import datetime\n\n&gt;&gt;&gt; import vectorbt as vbt\n\n&gt;&gt;&gt; # Prepare data\n&gt;&gt;&gt; start = '2019-01-01 UTC'  # crypto is in UTC\n&gt;&gt;&gt; end = '2020-01-01 UTC'\n&gt;&gt;&gt; btc_price = vbt.YFData.download('BTC-USD', start=start, end=end).get('Close')\n\n&gt;&gt;&gt; btc_price\nDate\n2019-01-01 00:00:00+00:00    3843.520020\n2019-01-02 00:00:00+00:00    3943.409424\n2019-01-03 00:00:00+00:00    3836.741211\n...                                  ...\n2019-12-30 00:00:00+00:00    7292.995117\n2019-12-31 00:00:00+00:00    7193.599121\n2020-01-01 00:00:00+00:00    7200.174316\nFreq: D, Name: Close, Length: 366, dtype: float64\n</code></pre> <p>We are going to test a simple Dual Moving Average Crossover (DMAC) strategy. For this, we are going to use <code>MA</code> class for calculating moving averages and generating signals.</p> <p>Our first test is rather simple: buy when the 10-day moving average crosses above the 20-day moving average, and sell when opposite.</p> <pre><code>&gt;&gt;&gt; fast_ma = vbt.MA.run(btc_price, 10, short_name='fast')\n&gt;&gt;&gt; slow_ma = vbt.MA.run(btc_price, 20, short_name='slow')\n\n&gt;&gt;&gt; entries = fast_ma.ma_crossed_above(slow_ma)\n&gt;&gt;&gt; entries\nDate\n2019-01-01 00:00:00+00:00    False\n2019-01-02 00:00:00+00:00    False\n2019-01-03 00:00:00+00:00    False\n...                            ...\n2019-12-30 00:00:00+00:00    False\n2019-12-31 00:00:00+00:00    False\n2020-01-01 00:00:00+00:00    False\nFreq: D, Length: 366, dtype: bool\n\n&gt;&gt;&gt; exits = fast_ma.ma_crossed_below(slow_ma)\n&gt;&gt;&gt; exits\nDate\n2019-01-01 00:00:00+00:00    False\n2019-01-02 00:00:00+00:00    False\n2019-01-03 00:00:00+00:00    False\n...                            ...\n2019-12-30 00:00:00+00:00    False\n2019-12-31 00:00:00+00:00    False\n2020-01-01 00:00:00+00:00    False\nFreq: D, Length: 366, dtype: bool\n\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(btc_price, entries, exits)\n&gt;&gt;&gt; pf.total_return()\n0.636680693047752\n</code></pre> <p>One strategy instance of DMAC produced one column in signals and one performance value.</p> <p>Adding one more strategy instance is as simple as adding one more column. Here we are passing an array of window sizes instead of a single value. For each window size in this array, it computes a moving average over the entire price series and stores it in a distinct column.</p> <pre><code>&gt;&gt;&gt; # Multiple strategy instances: (10, 30) and (20, 30)\n&gt;&gt;&gt; fast_ma = vbt.MA.run(btc_price, [10, 20], short_name='fast')\n&gt;&gt;&gt; slow_ma = vbt.MA.run(btc_price, [30, 30], short_name='slow')\n\n&gt;&gt;&gt; entries = fast_ma.ma_crossed_above(slow_ma)\n&gt;&gt;&gt; entries\nfast_window                   10     20\nslow_window                   30     30\nDate\n2019-01-01 00:00:00+00:00  False  False\n2019-01-02 00:00:00+00:00  False  False\n2019-01-03 00:00:00+00:00  False  False\n...                          ...    ...\n2019-12-30 00:00:00+00:00  False  False\n2019-12-31 00:00:00+00:00  False  False\n2020-01-01 00:00:00+00:00  False  False\n\n[366 rows x 2 columns]\n\n&gt;&gt;&gt; exits = fast_ma.ma_crossed_below(slow_ma)\n&gt;&gt;&gt; exits\nfast_window                   10     20\nslow_window                   30     30\nDate\n2019-01-01 00:00:00+00:00  False  False\n2019-01-02 00:00:00+00:00  False  False\n2019-01-03 00:00:00+00:00  False  False\n...                          ...    ...\n2019-12-30 00:00:00+00:00  False  False\n2019-12-31 00:00:00+00:00  False  False\n2020-01-01 00:00:00+00:00  False  False\n\n[366 rows x 2 columns]\n\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(btc_price, entries, exits)\n&gt;&gt;&gt; pf.total_return()\nfast_window  slow_window\n10           30             0.848840\n20           30             0.543411\nName: total_return, dtype: float64\n</code></pre> <p>For the sake of convenience, vectorbt has created the column levels <code>fast_window</code> and <code>slow_window</code> for us to easily distinguish which window size corresponds to which column.</p> <p>Notice how signal generation part remains the same for each example - most functions in vectorbt work on time series of any shape. This allows creation of analysis pipelines that are universal to input data.</p> <p>The representation of different features as columns offers endless possibilities for backtesting. We could, for example, go a step further and conduct the same tests for Ethereum. To compare both instruments, combine price series for Bitcoin and Ethereum into one DataFrame and run the same backtesting pipeline.</p> <pre><code>&gt;&gt;&gt; # Multiple strategy instances and instruments\n&gt;&gt;&gt; eth_price = vbt.YFData.download('ETH-USD', start=start, end=end).get('Close')\n&gt;&gt;&gt; comb_price = btc_price.vbt.concat(eth_price,\n...     keys=pd.Index(['BTC', 'ETH'], name='symbol'))\n&gt;&gt;&gt; comb_price.vbt.drop_levels(-1, inplace=True)\n&gt;&gt;&gt; comb_price\nsymbol                             BTC         ETH\nDate\n2019-01-01 00:00:00+00:00  3843.520020  140.819412\n2019-01-02 00:00:00+00:00  3943.409424  155.047684\n2019-01-03 00:00:00+00:00  3836.741211  149.135010\n...                                ...         ...\n2019-12-30 00:00:00+00:00  7292.995117  132.633484\n2019-12-31 00:00:00+00:00  7193.599121  129.610855\n2020-01-01 00:00:00+00:00  7200.174316  130.802002\n\n[366 rows x 2 columns]\n\n&gt;&gt;&gt; fast_ma = vbt.MA.run(comb_price, [10, 20], short_name='fast')\n&gt;&gt;&gt; slow_ma = vbt.MA.run(comb_price, [30, 30], short_name='slow')\n\n&gt;&gt;&gt; entries = fast_ma.ma_crossed_above(slow_ma)\n&gt;&gt;&gt; entries\nfast_window                          10            20\nslow_window                          30            30\nsymbol                       BTC    ETH    BTC    ETH\nDate\n2019-01-01 00:00:00+00:00  False  False  False  False\n2019-01-02 00:00:00+00:00  False  False  False  False\n2019-01-03 00:00:00+00:00  False  False  False  False\n...                          ...    ...    ...    ...\n2019-12-30 00:00:00+00:00  False  False  False  False\n2019-12-31 00:00:00+00:00  False  False  False  False\n2020-01-01 00:00:00+00:00  False  False  False  False\n\n[366 rows x 4 columns]\n\n&gt;&gt;&gt; exits = fast_ma.ma_crossed_below(slow_ma)\n&gt;&gt;&gt; exits\nfast_window                          10            20\nslow_window                          30            30\nsymbol                       BTC    ETH    BTC    ETH\nDate\n2019-01-01 00:00:00+00:00  False  False  False  False\n2019-01-02 00:00:00+00:00  False  False  False  False\n2019-01-03 00:00:00+00:00  False  False  False  False\n...                          ...    ...    ...    ...\n2019-12-30 00:00:00+00:00  False  False  False  False\n2019-12-31 00:00:00+00:00  False  False  False  False\n2020-01-01 00:00:00+00:00  False  False  False  False\n\n[366 rows x 4 columns]\n\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(comb_price, entries, exits)\n&gt;&gt;&gt; pf.total_return()\nfast_window  slow_window  symbol\n10           30           BTC       0.848840\n                          ETH       0.244204\n20           30           BTC       0.543411\n                          ETH      -0.319102\nName: total_return, dtype: float64\n\n&gt;&gt;&gt; mean_return = pf.total_return().groupby('symbol').mean()\n&gt;&gt;&gt; mean_return.vbt.barplot(xaxis_title='Symbol', yaxis_title='Mean total return')\n</code></pre> <p></p> <p>Not only strategies and instruments can act as separate features, but also time. If we want to find out when our strategy performs best, it's reasonable to backtest over multiple time periods. vectorbt allows us to split one time period into many, given they have the same length and frequency, and represent them as distinct columns. For example, let's split the whole time period into two equal time periods and backest them at once.</p> <pre><code>&gt;&gt;&gt; # Multiple strategy instances, instruments, and time periods\n&gt;&gt;&gt; mult_comb_price, _ = comb_price.vbt.range_split(n=2)\n&gt;&gt;&gt; mult_comb_price\nsplit_idx                         0                         1\nsymbol              BTC         ETH           BTC         ETH\n0           3843.520020  140.819412  11961.269531  303.099976\n1           3943.409424  155.047684  11215.437500  284.523224\n2           3836.741211  149.135010  10978.459961  287.997528\n...                 ...         ...           ...         ...\n180        10817.155273  290.695984   7292.995117  132.633484\n181        10583.134766  293.641113   7193.599121  129.610855\n182        10801.677734  291.596436   7200.174316  130.802002\n\n[183 rows x 4 columns]\n\n&gt;&gt;&gt; fast_ma = vbt.MA.run(mult_comb_price, [10, 20], short_name='fast')\n&gt;&gt;&gt; slow_ma = vbt.MA.run(mult_comb_price, [30, 30], short_name='slow')\n\n&gt;&gt;&gt; entries = fast_ma.ma_crossed_above(slow_ma)\n&gt;&gt;&gt; exits = fast_ma.ma_crossed_below(slow_ma)\n\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(mult_comb_price, entries, exits, freq='1D')\n&gt;&gt;&gt; pf.total_return()\nfast_window  slow_window  split_idx  symbol\n10           30           0          BTC       1.632259\n                                     ETH       0.946786\n                          1          BTC      -0.288720\n                                     ETH      -0.308387\n20           30           0          BTC       1.721449\n                                     ETH       0.343274\n                          1          BTC      -0.418280\n                                     ETH      -0.257947\nName: total_return, dtype: float64\n</code></pre> <p>Notice how index is no more datetime-like, since it captures multiple time periods. That's why it's required here to pass the frequency <code>freq</code> to the <code>Portfolio</code> class in order to be able to compute performance metrics such as the Sharpe ratio.</p> <p>The index hierarchy of the final performance series can be then used to group the performance by any feature, such as window pair, symbol, and time period.</p> <pre><code>&gt;&gt;&gt; mean_return = pf.total_return().groupby(['split_idx', 'symbol']).mean()\n&gt;&gt;&gt; mean_return.unstack(level=-1).vbt.barplot(\n...     xaxis_title='Split index',\n...     yaxis_title='Mean total return',\n...     legend_title_text='Symbol')\n</code></pre> <p></p> <p>There is much more to backtesting than simply stacking columns: vectorbt offers functions for most parts of a backtesting pipeline - from building indicators and generating signals, to modeling portfolio performance and visualizing results.</p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>This software is for educational purposes only. Do not risk money which you are afraid to lose. USE THE SOFTWARE AT YOUR OWN RISK. THE AUTHORS AND ALL AFFILIATES ASSUME NO RESPONSIBILITY FOR YOUR TRADING RESULTS.</p>"},{"location":"documentation/","title":"Documentation","text":"<p>Documentation is distributed across the API. </p> <p>For example, the documentation for data: https://vectorbt.dev/api/data/base/</p> <p>The proper documentation is being developed as part of vectorbt.pro, and while  it touches the next-generation version of vectorbt, you can still find many overlapping concepts and examples. </p> <p>Documentation</p>"},{"location":"getting-started/contributing/","title":"Contributing","text":"<p>Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.</p> <p>First, you need to install vectorbt from the repository:</p> <pre><code>pip uninstall vectorbt\ngit clone https://github.com/polakowo/vectorbt.git\ncd vectorbt\npip install -e .\n</code></pre> <p>After making changes, make sure you did not break any functionality:</p> <pre><code>pytest\n</code></pre> <p>Make sure to update tests as appropriate.</p>"},{"location":"getting-started/features/","title":"Features","text":""},{"location":"getting-started/features/#pandas","title":"Pandas","text":"<ul> <li> Pandas acceleration: Compiled versions of most popular pandas functions, such as mapping, reducing, rolling, grouping, and resamping. For best performance, most operations are done strictly using NumPy and Numba. Attaches a custom accessor on top of pandas to easily switch between pandas and vectorbt functionality.</li> </ul> Compute the rolling z-score<pre><code>&gt;&gt;&gt; import vectorbt as vbt\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from numba import njit\n\n&gt;&gt;&gt; big_ts = pd.DataFrame(np.random.uniform(size=(1000, 1000)))\n\n# pandas\n&gt;&gt;&gt; @njit\n... def zscore_nb(x):\n...     return (x[-1] - np.mean(x)) / np.std(x)\n\n&gt;&gt;&gt; %timeit big_ts.rolling(2).apply(zscore_nb, raw=True)\n482 ms \u00b1 393 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n\n# vectorbt\n&gt;&gt;&gt; @njit\n... def vbt_zscore_nb(i, col, x):\n...     return zscore_nb(x)\n\n&gt;&gt;&gt; %timeit big_ts.vbt.rolling_apply(2, vbt_zscore_nb)\n33.1 ms \u00b1 1.17 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</code></pre> <ul> <li> Flexible broadcasting: Mechanism for broadcasting array-like objects of arbitrary shapes, including pandas objects with MultiIndex.</li> </ul> Broadcast pandas objects properly<pre><code>&gt;&gt;&gt; sr = pd.Series([1, 2, 3], index=['x', 'y', 'z'])\n&gt;&gt;&gt; df = pd.DataFrame([[4, 5, 6]], index=['x', 'y', 'z'], columns=['a', 'b', 'c'])\n\n# pandas\n&gt;&gt;&gt; sr + df\n    a   b   c   x   y   z\nx NaN NaN NaN NaN NaN NaN\ny NaN NaN NaN NaN NaN NaN\nz NaN NaN NaN NaN NaN NaN\n\n# vectorbt\n&gt;&gt;&gt; sr.vbt + df\n   a  b  c\nx  5  6  7\ny  6  7  8\nz  7  8  9\n</code></pre> <ul> <li> Pandas utilities: Grouping columns, wrapping NumPy arrays, transforming pandas objects and their indexes, and more.</li> </ul> Build a symmetric matrix<pre><code>&gt;&gt;&gt; pd.Series([1, 2, 3]).vbt.make_symmetric()\n     0    1    2\n0  1.0  2.0  3.0\n1  2.0  NaN  NaN\n2  3.0  NaN  NaN\n</code></pre>"},{"location":"getting-started/features/#data","title":"Data","text":"<ul> <li> Data acquisition: Supports various data providers, such as Yahoo Finance, Binance, CCXT and Alpaca. Can merge multiple symbols with different index, as well as update them.</li> </ul> Download Alpaca data<pre><code>&gt;&gt;&gt; alpaca_data = vbt.AlpacaData.download(\n...     \"AAPL\",\n...     start='2 hours ago UTC',\n...     end='15 minutes ago UTC',\n...     interval='1m'\n... )\n&gt;&gt;&gt; alpaca_data.get()\n                           Open      High       Low     Close      Volume\ntimestamp                                                                \n2021-12-27 14:04:00+00:00  177.0500  177.0500  177.0500  177.0500    1967\n2021-12-27 14:05:00+00:00  177.0500  177.0500  177.0300  177.0500    3218\n2021-12-27 14:06:00+00:00  177.0400  177.0400  177.0400  177.0400     873\n...                             ...       ...       ...       ...     ...\n2021-12-27 15:46:00+00:00  177.9500  178.0000  177.8289  177.8850  162778\n2021-12-27 15:47:00+00:00  177.8810  177.9600  177.8400  177.9515  123284\n2021-12-27 15:48:00+00:00  177.9600  178.0500  177.9600  178.0100  159700\n\n[105 rows x 5 columns]\n</code></pre> <ul> <li> Data generation: Supports various (random) data generators, such as GBM.</li> </ul> Generate random data using Geometric Brownian Motion<pre><code>&gt;&gt;&gt; gbm_data = vbt.GBMData.download(\n...     list(range(5)),\n...     start='2020-01-01',\n...     end='2021-01-01'\n... )\n&gt;&gt;&gt; gbm_data.plot(showlegend=False)\n</code></pre> <ul> <li> Scheduled data updates: Can periodically update any previously downloaded data.</li> </ul> Append random data every 5 seconds<pre><code>&gt;&gt;&gt; class MyDataUpdater(vbt.DataUpdater):\n...     def update(self, count_limit=None):\n...         prev_index_len = len(self.data.wrapper.index)\n...         super().update()\n...         new_index_len = len(self.data.wrapper.index)\n...         print(f\"Data updated with {new_index_len - prev_index_len} data points\")\n\n&gt;&gt;&gt; data = vbt.GBMData.download('SYMBOL', start='1 minute ago', freq='1s')\n&gt;&gt;&gt; my_updater = MyDataUpdater(data)\n&gt;&gt;&gt; my_updater.update_every(5, 'seconds')\nData updated with 5 data points\nData updated with 5 data points\n...\n</code></pre> <ul> <li> Data preparation: Transformation, rescaling, and normalization of data. Custom splitters for cross-validation. Supports Scikit-Learn splitters, such as for K-Folds cross-validation.</li> </ul> Split time series data<pre><code>&gt;&gt;&gt; from datetime import datetime, timedelta\n\n&gt;&gt;&gt; index = [datetime(2020, 1, 1) + timedelta(days=i) for i in range(10)]\n&gt;&gt;&gt; sr = pd.Series(np.arange(len(index)), index=index)\n&gt;&gt;&gt; sr.vbt.rolling_split(\n...     window_len=5, \n...     set_lens=(1, 1), \n...     left_to_right=False, \n...     plot=True, \n...     trace_names=['train', 'valid', 'test'])\n</code></pre> <ul> <li> Labeling for ML: Discrete and continuous label generation for effective training of ML models.</li> </ul> Identify local extrema<pre><code>&gt;&gt;&gt; price = np.cumprod(np.random.uniform(-0.1, 0.1, size=100) + 1)\n&gt;&gt;&gt; vbt.LEXLB.run(price, 0.2, 0.2).plot()\n</code></pre>"},{"location":"getting-started/features/#indicators","title":"Indicators","text":"<ul> <li> Technical indicators: Most popular technical indicators with full Numba support, including Moving Average, Bollinger Bands, RSI, Stochastic, MACD, and more. Out-of-the-box support for 99% indicators in Technical Analysis Library, Pandas TA, and TA-Lib thanks to built-in parsers. Each indicator is wrapped with the vectorbt's indicator engine and thus accepts arbitrary hyperparameter combinations - from arrays to Cartesian products.</li> </ul> Compute 2 moving averages at once<pre><code>&gt;&gt;&gt; price = pd.Series([1, 2, 3, 4, 5], dtype=float)\n\n# built-in\n&gt;&gt;&gt; vbt.MA.run(price, [2, 3]).ma\nma_window    2    3\n0          NaN  NaN\n1          1.5  NaN\n2          2.5  2.0\n3          3.5  3.0\n4          4.5  4.0\n\n# ta support\n&gt;&gt;&gt; vbt.ta('SMAIndicator').run(price, [2, 3]).sma_indicator\nsmaindicator_window    2    3\n0                    NaN  NaN\n1                    1.5  NaN\n2                    2.5  2.0\n3                    3.5  3.0\n4                    4.5  4.0\n\n# pandas-ta support\n&gt;&gt;&gt; vbt.pandas_ta('SMA').run(price, [2, 3]).sma\nsma_length    2    3\n0           NaN  NaN\n1           1.5  NaN\n2           2.5  2.0\n3           3.5  3.0\n4           4.5  4.0\n\n# TA-Lib support\n&gt;&gt;&gt; vbt.talib('SMA').run(price, [2, 3]).real\nsma_timeperiod    2    3\n0               NaN  NaN\n1               1.5  NaN\n2               2.5  2.0\n3               3.5  3.0\n4               4.5  4.0\n</code></pre> <ul> <li> Indicator factory: Sophisticated factory for building custom technical indicators of any complexity. Takes a function and does all the magic for you: generates an indicator skeleton that takes inputs and parameters of any shape and type, and runs the vectorbt's indicator engine. The easiest and most flexible way to create indicators you will find in open source.</li> </ul> Construct a random indicator<pre><code>&gt;&gt;&gt; @njit\n... def apply_func_nb(input_shape, start, mu, sigma):\n...     rand_returns = np.random.normal(mu, sigma, input_shape)\n...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)\n\n&gt;&gt;&gt; RandomInd = vbt.IndicatorFactory(\n...     param_names=['start', 'mu', 'sigma'],\n...     output_names=['output']\n... ).from_apply_func(\n...     apply_func_nb,\n...     require_input_shape=True,\n...     seed=42\n... )\n\n&gt;&gt;&gt; RandomInd.run(5, [100, 200], [-0.01, 0.01], 0.01).output\ncustom_start        100         200\ncustom_mu         -0.01        0.01\ncustom_sigma       0.01        0.01\n0             99.496714  201.531726\n1             98.364179  206.729658\n2             98.017630  210.383470\n3             98.530292  211.499608\n4             97.314277  214.762117\n</code></pre>"},{"location":"getting-started/features/#signals","title":"Signals","text":"<ul> <li> Signal analysis: Generation, mapping and reducing, ranking, and distribution analysis of entry and exit signals.</li> </ul> Measure each partition of True values<pre><code>&gt;&gt;&gt; mask_sr = pd.Series([True, True, True, False, True, True])\n&gt;&gt;&gt; mask_sr.vbt.signals.partition_ranges().duration.values\narray([3, 2])\n</code></pre> <ul> <li> Signal generators: Random and stop loss (SL, TSL, TP, etc.) signal generators with full Numba support.</li> </ul> Generate entries and exits using different probabilities<pre><code>&gt;&gt;&gt; rprobnx = vbt.RPROBNX.run(\n...     input_shape=(5,),\n...     entry_prob=[0.5, 1.],\n...     exit_prob=[0.5, 1.],\n...     param_product=True,\n...     seed=42)\n\n&gt;&gt;&gt; rprobnx.entries\nrprobnx_entry_prob    0.5    0.5    1.0    0.5\nrprobnx_exit_prob     0.5    1.0    0.5    1.0\n0                    True   True   True   True\n1                   False  False  False  False\n2                   False  False  False   True\n3                   False  False  False  False\n4                   False  False   True   True\n\n&gt;&gt;&gt; rprobnx.exits\nrprobnx_entry_prob    0.5    0.5    1.0    1.0\nrprobnx_exit_prob     0.5    1.0    0.5    1.0\n0                   False  False  False  False\n1                   False   True  False   True\n2                   False  False  False  False\n3                   False  False   True   True\n4                    True  False  False  False\n</code></pre> <ul> <li> Signal factory: Signal factory based on indicator factory specialized for iterative signal generation.</li> </ul> Place entries and exits using custom functions<pre><code>&gt;&gt;&gt; @njit\n... def entry_choice_func(from_i, to_i, col):\n...     return np.array([col])\n\n&gt;&gt;&gt; @njit\n... def exit_choice_func(from_i, to_i, col):\n...     return np.array([to_i - 1])\n\n&gt;&gt;&gt; MySignals = vbt.SignalFactory().from_choice_func(\n...     entry_choice_func=entry_choice_func,\n...     exit_choice_func=exit_choice_func,\n...     entry_kwargs=dict(wait=1),\n...     exit_kwargs=dict(wait=0)\n... )\n\n&gt;&gt;&gt; my_sig = MySignals.run(input_shape=(3, 3))\n&gt;&gt;&gt; my_sig.entries\n       0      1      2\n0   True  False  False\n1  False   True  False\n2  False  False   True\n&gt;&gt;&gt; my_sig.exits\n       0      1      2\n0  False  False  False\n1  False  False  False\n2   True   True   True\n</code></pre>"},{"location":"getting-started/features/#modeling","title":"Modeling","text":"<ul> <li> Portfolio modeling: The fastest backtesting engine in open source: fills 1,000,000 orders in 70-100ms on Apple M1. Flexible and powerful simulation functions for portfolio modeling, highly optimized for highest performance and lowest memory footprint. Supports two major simulation modes: 1) vectorized backtesting using user-provided arrays, such as orders, signals, and records, and 2) event-driven backtesting using user-defined callbacks. Supports shorting and individual as well as multi-asset mixed portfolios. Combines many features across vectorbt into a single behemoth class.</li> </ul> Backtest the Golden Cross<pre><code>&gt;&gt;&gt; price = vbt.YFData.download('BTC-USD', start='2018-01-01').get('Close')\n&gt;&gt;&gt; fast_ma = vbt.MA.run(price, 50, short_name='fast_ma')\n&gt;&gt;&gt; slow_ma = vbt.MA.run(price, 200, short_name='slow_ma')\n&gt;&gt;&gt; entries = fast_ma.ma_crossed_above(slow_ma)\n&gt;&gt;&gt; exits = fast_ma.ma_crossed_below(slow_ma)\n&gt;&gt;&gt; pf = vbt.Portfolio.from_signals(price, entries, exits, fees=0.005)\n\n&gt;&gt;&gt; pf.orders.records_readable\n   Order Id  Column                 Timestamp      Size         Price  \\\\\n0         0       0 2019-04-24 00:00:00+00:00  0.018208   5464.866699   \n1         1       0 2019-10-26 00:00:00+00:00  0.018208   9244.972656   \n2         2       0 2020-02-19 00:00:00+00:00  0.017300   9633.386719   \n3         3       0 2020-03-25 00:00:00+00:00  0.017300   6681.062988   \n4         4       0 2020-05-21 00:00:00+00:00  0.012600   9081.761719   \n5         5       0 2021-06-19 00:00:00+00:00  0.012600  35615.871094   \n6         6       0 2021-09-15 00:00:00+00:00  0.009222  48176.347656   \n\n       Fees  Side  \n0  0.497512   Buy  \n1  0.841647  Sell  \n2  0.833272   Buy  \n3  0.577901  Sell  \n4  0.572151   Buy  \n5  2.243800  Sell  \n6  2.221473   Buy  \n\n&gt;&gt;&gt; fig = price.vbt.plot(trace_kwargs=dict(name='Close'))\n&gt;&gt;&gt; fast_ma.ma.vbt.plot(trace_kwargs=dict(name='Fast MA'), fig=fig)\n&gt;&gt;&gt; slow_ma.ma.vbt.plot(trace_kwargs=dict(name='Slow MA'), fig=fig)\n&gt;&gt;&gt; pf.positions.plot(close_trace_kwargs=dict(visible=False), fig=fig)\n</code></pre>"},{"location":"getting-started/features/#analysis","title":"Analysis","text":"<ul> <li> Performance metrics: Numba-compiled versions of metrics from empyrical and their rolling versions. Adapter for QuantStats.</li> </ul> Visualize performance using QuantStats<pre><code>&gt;&gt;&gt; price = vbt.YFData.download('BTC-USD').get('Close')\n&gt;&gt;&gt; returns = price.vbt.to_returns()\n&gt;&gt;&gt; returns.vbt.returns.qs.plot_snapshot()\n</code></pre> <ul> <li> Stats builder: Class for building statistics out of custom metrics. Implements a preset of tailored statistics for many backtesting components, such as signals, returns, and portfolio.</li> </ul> Analyze the distribution of signals in a mask<pre><code>&gt;&gt;&gt; index = [datetime(2020, 1, 1) + timedelta(days=i) for i in range(7)]\n&gt;&gt;&gt; mask = pd.Series([False, True, True, True, False, True, False])\n&gt;&gt;&gt; mask.vbt.signals(freq='d').stats()\nStart                                               0\nEnd                                                 6\nPeriod                                7 days 00:00:00\nTotal                                               4\nRate [%]                                    57.142857\nFirst Index                                         1\nLast Index                                          5\nNorm Avg Index [-1, 1]                      -0.083333\nDistance: Min                         1 days 00:00:00\nDistance: Max                         2 days 00:00:00\nDistance: Mean                        1 days 08:00:00\nDistance: Std               0 days 13:51:23.063257983\nTotal Partitions                                    2\nPartition Rate [%]                               50.0\nPartition Length: Min                 1 days 00:00:00\nPartition Length: Max                 3 days 00:00:00\nPartition Length: Mean                2 days 00:00:00\nPartition Length: Std       1 days 09:56:28.051789035\nPartition Distance: Min               2 days 00:00:00\nPartition Distance: Max               2 days 00:00:00\nPartition Distance: Mean              2 days 00:00:00\nPartition Distance: Std                           NaT\ndtype: object\n</code></pre> <ul> <li> Records and mapped arrays: In-house data structures for analyzing complex data, such as simulation logs. Fully compiled with Numba.</li> </ul> Parse 5 highest slippage values from logs<pre><code>&gt;&gt;&gt; price = vbt.YFData.download('BTC-USD').get('Close')\n&gt;&gt;&gt; slippage = np.random.uniform(0, 0.005, size=price.shape[0])\n&gt;&gt;&gt; logs = vbt.Portfolio.from_random_signals(price, n=5, slippage=slippage, log=True).logs\n\n&gt;&gt;&gt; req_price_ma = logs.map_field('req_price')\n&gt;&gt;&gt; res_price_ma = logs.map_field('res_price')\n&gt;&gt;&gt; slippage_ma = (res_price_ma - req_price_ma) / req_price_ma\n&gt;&gt;&gt; slippage_ma = slippage_ma.replace(arr=np.abs(slippage_ma.values))\n&gt;&gt;&gt; top_slippage_pd = slippage_ma.top_n(5).to_pd()\n&gt;&gt;&gt; top_slippage_pd[~top_slippage_pd.isnull()]\nDate\n2017-12-25 00:00:00+00:00    0.001534\n2018-06-03 00:00:00+00:00    0.004354\n2018-12-03 00:00:00+00:00    0.004663\n2019-09-20 00:00:00+00:00    0.004217\n2020-11-28 00:00:00+00:00    0.000775\ndtype: float64\n</code></pre> <ul> <li> Trade analysis: Retrospective analysis of trades from various view points. Supports entry trades, exit trades, and positions.</li> </ul> Get the projected return of each buy order<pre><code>&gt;&gt;&gt; price = vbt.YFData.download('BTC-USD').get('Close')\n&gt;&gt;&gt; entry_trades = vbt.Portfolio.from_random_signals(price, n=5).entry_trades\n&gt;&gt;&gt; returns_pd = entry_trades.returns.to_pd()\n&gt;&gt;&gt; returns_pd[~returns_pd.isnull()]\nDate\n2017-11-12 00:00:00+00:00    0.742975\n2019-08-30 00:00:00+00:00   -0.081744\n2020-04-21 00:00:00+00:00    0.489072\n2020-09-13 00:00:00+00:00    0.262251\n2021-03-07 00:00:00+00:00   -0.382155\ndtype: float64\n</code></pre> <ul> <li> Drawdown analysis: Drawdown statistics of any numeric time series.</li> </ul> Plot 3 deepest price dips<pre><code>&gt;&gt;&gt; price = vbt.YFData.download('BTC-USD').get('Close')\n&gt;&gt;&gt; price.vbt.drawdowns.plot(top_n=3)\n</code></pre>"},{"location":"getting-started/features/#plotting","title":"Plotting","text":"<ul> <li> Data visualization: Numerous flexible data plotting functions distributed across vectorbt.</li> </ul> Plot time series against each other<pre><code>&gt;&gt;&gt; sr1 = pd.Series(np.cumprod(np.random.normal(0, 0.01, 100) + 1))\n&gt;&gt;&gt; sr2 = pd.Series(np.cumprod(np.random.normal(0, 0.01, 100) + 1))\n&gt;&gt;&gt; sr1.vbt.plot_against(sr2)\n</code></pre> <ul> <li> Figures and widgets: Custom interactive figures and widgets using Plotly, such as Heatmap and Volume. All custom widgets have dedicated methods for efficiently updating their state.</li> </ul> Plot a volume<pre><code>&gt;&gt;&gt; volume_widget = vbt.plotting.Volume(\n...     data=np.random.randint(1, 10, size=(3, 3, 3)),\n...     x_labels=['a', 'b', 'c'],\n...     y_labels=['d', 'e', 'f'],\n...     z_labels=['g', 'h', 'i']\n... )\n&gt;&gt;&gt; volume_widget.fig\n</code></pre> <ul> <li> Plots builder: Class for building plots out of custom subplots. Implements a preset of tailored subplots for many backtesting components, such as signals, returns, and portfolio.</li> </ul> Plot various portfolio balances<pre><code>&gt;&gt;&gt; price = vbt.YFData.download('BTC-USD').get('Close')\n&gt;&gt;&gt; pf = vbt.Portfolio.from_random_signals(price, n=5)\n&gt;&gt;&gt; pf.plot(subplots=['cash', 'assets', 'value']).show_svg()\n</code></pre>"},{"location":"getting-started/features/#extra","title":"Extra","text":"<ul> <li> Notifications: Telegram bot based on Python Telegram Bot.</li> </ul> Launch a bot that returns the latest ticker on Binance<pre><code>&gt;&gt;&gt; from telegram.ext import CommandHandler\n&gt;&gt;&gt; import ccxt\n\n&gt;&gt;&gt; class BinanceTickerBot(vbt.TelegramBot):\n...     @property\n...     def custom_handlers(self):\n...         return CommandHandler('get', self.get),\n...\n...     @property\n...     def help_message(self):\n...         return \"Type /get [symbol] to get the latest ticker on Binance.\"\n...\n...     def get(self, update, context):\n...         chat_id = update.effective_chat.id\n...         try:\n...             ticker = ccxt.binance().fetchTicker(context.args[0])\n...         except Exception as e:\n...             self.send_message(chat_id, str(e))\n...             return\n...         self.send_message(chat_id, str(ticker['last']))\n\n&gt;&gt;&gt; bot = BinanceTickerBot(token='YOUR_TOKEN')\n&gt;&gt;&gt; bot.start()\n</code></pre> <ul> <li> General utilities: Scheduling using schedule, templates, decorators, configs, and more.</li> </ul> Every 10 seconds display the latest Bitcoin trades on Binance<pre><code>&gt;&gt;&gt; from vectorbt.utils.datetime_ import datetime_to_ms, to_tzaware_datetime, get_utc_tz\n&gt;&gt;&gt; from IPython.display import SVG, display, clear_output\n\n&gt;&gt;&gt; exchange = ccxt.binance()\n\n&gt;&gt;&gt; def job_func():\n...     since = datetime_to_ms(to_tzaware_datetime('10 seconds ago UTC', tz=get_utc_tz()))\n...     trades = exchange.fetch_trades('BTC/USDT', since)\n...     price = pd.Series({t['datetime']: t['price'] for t in trades})\n...     svg = price.vbt.plot().to_image(format=\"svg\")\n...     clear_output()\n...     display(SVG(svg))\n\n&gt;&gt;&gt; scheduler = vbt.ScheduleManager()\n&gt;&gt;&gt; scheduler.every(10, 'seconds').do(job_func)\n&gt;&gt;&gt; scheduler.start()\n</code></pre> <ul> <li> Caching: Property and method decorators for caching most frequently used objects.</li> </ul> Create a cached method and disable it globally<pre><code>&gt;&gt;&gt; import time\n&gt;&gt;&gt; start = time.time()\n\n&gt;&gt;&gt; class MyClass:\n...     @vbt.cached_method\n...     def get_elapsed(self):\n...         return time.time() - start\n\n&gt;&gt;&gt; my_inst = MyClass()\n&gt;&gt;&gt; my_inst.get_elapsed()\n0.00010895729064941406\n\n&gt;&gt;&gt; my_inst.get_elapsed()\n0.00010895729064941406\n\n&gt;&gt;&gt; get_elapsed_cond = vbt.CacheCondition(instance=my_inst, func='get_elapsed')\n&gt;&gt;&gt; vbt.settings.caching['blacklist'].append(get_elapsed_cond)\n&gt;&gt;&gt; my_inst.get_elapsed()\n0.01081395149230957\n</code></pre> <ul> <li> Persistance: Most Python objects including data and portfolio can be saved to a file and retrieved back using Dill.</li> </ul> Simulate, save, and load back a portfolio<pre><code>&gt;&gt;&gt; price = vbt.YFData.download('BTC-USD').get('Close')\n&gt;&gt;&gt; pf = vbt.Portfolio.from_random_signals(price, n=5)\n&gt;&gt;&gt; pf.save('my_pf.pkl')\n\n&gt;&gt;&gt; pf = vbt.Portfolio.load('my_pf.pkl')\n&gt;&gt;&gt; pf.total_return()\n5.96813681074424\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>You can install vectorbt with pip, the Python package manager, or with Docker.</p>"},{"location":"getting-started/installation/#with-pip","title":"With pip","text":"<pre><code>pip install -U vectorbt\n</code></pre> <p>To also install optional dependencies:</p> <pre><code>pip install -U \"vectorbt[full]\"\n</code></pre>"},{"location":"getting-started/installation/#with-docker","title":"With Docker","text":"<p>You can pull the most recent Docker image if you have Docker installed.</p> <pre><code>docker run --rm -p 8888:8888 -v \"$PWD\":/home/jovyan/work polakowo/vectorbt\n</code></pre> <p>This command pulls the latest <code>polakowo/vectorbt</code> image from Docker Hub. It then starts a container running  a Jupyter Notebook server and exposes the server on host port 8888. Visiting <code>http://127.0.0.1:8888/?token=&lt;token&gt;</code>  in a browser loads JupyterLab, where token is the secret token printed in the console. Docker destroys  the container after notebook server exit, but any files written to the working directory in the container  remain intact in the working directory on the host. See Jupyter Docker Stacks - Quick Start.</p> <p>There are two types of images: </p> <ul> <li>polakowo/vectorbt: vanilla version (default)</li> <li>polakowo/vectorbt-full: full version (with optional dependencies)</li> </ul> <p>Each Docker image is based on jupyter/scipy-notebook  and comes with Jupyter environment, vectorbt, and other scientific packages installed.</p>"},{"location":"getting-started/installation/#with-git","title":"With git","text":"<p>Of course, you can pull vectorbt directly from <code>git</code>:</p> <pre><code>git clone git@github.com:polakowo/vectorbt.git vectorbt\n</code></pre> <p>Install the package:</p> <pre><code>pip install -e vectorbt\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>TA-Lib</li> <li>Jupyter Notebook and JupyterLab</li> <li>Apple M1</li> </ul>"},{"location":"getting-started/resources/","title":"Resources","text":"<p>Here's a collection of resources to get started.</p>"},{"location":"getting-started/resources/#notebooks","title":"Notebooks","text":"<ul> <li>Performance analysis of Moving Average Crossover</li> <li>Performance analysis of stop signals</li> <li>Backtesting per trading session</li> <li>Portfolio optimization</li> <li>Plotting MACD parameters as 3D volume</li> <li>Walk-forward optimization</li> <li>Running Telegram signal bot</li> <li>Porting RSI strategy from backtrader</li> <li>Pairs trading (vs backtrader)</li> </ul> <p>Note: you must run the notebook to play with the widgets.</p>"},{"location":"getting-started/resources/#dashboards","title":"Dashboards","text":"<ul> <li>Detecting and backtesting common candlestick patterns</li> </ul>"},{"location":"getting-started/resources/#articles","title":"Articles","text":"<ul> <li>Stop Loss, Trailing Stop, or Take Profit? 2 Million Backtests Shed Light</li> <li>SuperFast SuperTrend</li> <li>The PyQuant Newsletter <ul> <li>1,000,000 backtest simulations in 20 seconds</li> </ul> </li> </ul>"},{"location":"getting-started/resources/#books","title":"Books","text":"<ul> <li>Python for Algorithmic Trading Cookbook: Recipes for designing, building, and deploying algorithmic trading strategies with Python</li> </ul> CoverBack Cover"},{"location":"getting-started/resources/#getting-help","title":"Getting Help","text":"<ul> <li>For questions on Numba and other parts, the best place to go to is StackOverflow</li> <li>If you have general questions, start a new GitHub Discussion</li> <li>If you found what appears to be a bug, please create a new issue</li> </ul>"},{"location":"getting-started/usage/","title":"Usage","text":"<p>vectorbt allows you to easily backtest strategies with a couple of lines of Python code.</p> <ul> <li>Here is how much profit we would have made if we invested $100 into Bitcoin in 2014:</li> </ul> <pre><code>import vectorbt as vbt\n\nprice = vbt.YFData.download('BTC-USD').get('Close')\n\npf = vbt.Portfolio.from_holding(price, init_cash=100)\npf.total_profit()\n</code></pre> <pre><code>8961.008555963961\n</code></pre> <ul> <li>Buy whenever 10-day SMA crosses above 50-day SMA and sell when opposite:</li> </ul> <pre><code>fast_ma = vbt.MA.run(price, 10)\nslow_ma = vbt.MA.run(price, 50)\nentries = fast_ma.ma_crossed_above(slow_ma)\nexits = fast_ma.ma_crossed_below(slow_ma)\n\npf = vbt.Portfolio.from_signals(price, entries, exits, init_cash=100)\npf.total_profit()\n</code></pre> <pre><code>16423.251963801864\n</code></pre> <ul> <li>Generate 1,000 strategies with random signals and test them on BTC and ETH:</li> </ul> <pre><code>import numpy as np\n\nsymbols = [\"BTC-USD\", \"ETH-USD\"]\nprice = vbt.YFData.download(symbols, missing_index='drop').get('Close')\n\nn = np.random.randint(10, 101, size=1000).tolist()\npf = vbt.Portfolio.from_random_signals(price, n=n, init_cash=100, seed=42)\n\nmean_expectancy = pf.trades.expectancy().groupby(['randnx_n', 'symbol']).mean()\nfig = mean_expectancy.unstack().vbt.scatterplot(xaxis_title='randnx_n', yaxis_title='mean_expectancy')\nfig.show()\n</code></pre> <p></p> <ul> <li>For fans of hyperparameter optimization: here is a snippet for testing 10,000 window combinations of a  dual SMA crossover strategy on BTC, USD, and LTC:</li> </ul> <pre><code>symbols = [\"BTC-USD\", \"ETH-USD\", \"LTC-USD\"]\nprice = vbt.YFData.download(symbols, missing_index='drop').get('Close')\n\nwindows = np.arange(2, 101)\nfast_ma, slow_ma = vbt.MA.run_combs(price, window=windows, r=2, short_names=['fast', 'slow'])\nentries = fast_ma.ma_crossed_above(slow_ma)\nexits = fast_ma.ma_crossed_below(slow_ma)\n\npf_kwargs = dict(size=np.inf, fees=0.001, freq='1D')\npf = vbt.Portfolio.from_signals(price, entries, exits, **pf_kwargs)\n\nfig = pf.total_return().vbt.heatmap(\n    x_level='fast_window', y_level='slow_window', slider_level='symbol', symmetric=True,\n    trace_kwargs=dict(colorbar=dict(title='Total return', tickformat='%')))\nfig.show()\n</code></pre> <p></p> <p>Digging into each strategy configuration is as simple as indexing with pandas:</p> <pre><code>pf[(10, 20, 'ETH-USD')].stats()\n</code></pre> <pre><code>Start                          2015-08-07 00:00:00+00:00\nEnd                            2021-08-01 00:00:00+00:00\nPeriod                                2183 days 00:00:00\nStart Value                                        100.0\nEnd Value                                  620402.791485\nTotal Return [%]                           620302.791485\nBenchmark Return [%]                        92987.961948\nMax Gross Exposure [%]                             100.0\nTotal Fees Paid                             10991.676981\nMax Drawdown [%]                               70.734951\nMax Drawdown Duration                  760 days 00:00:00\nTotal Trades                                          54\nTotal Closed Trades                                   53\nTotal Open Trades                                      1\nOpen Trade PnL                              67287.940601\nWin Rate [%]                                   52.830189\nBest Trade [%]                               1075.803607\nWorst Trade [%]                               -29.593414\nAvg Winning Trade [%]                          95.695343\nAvg Losing Trade [%]                          -11.890246\nAvg Winning Trade Duration    35 days 23:08:34.285714286\nAvg Losing Trade Duration                8 days 00:00:00\nProfit Factor                                   2.651143\nExpectancy                                   10434.24247\nSharpe Ratio                                    2.041211\nCalmar Ratio                                      4.6747\nOmega Ratio                                     1.547013\nSortino Ratio                                   3.519894\nName: (10, 20, ETH-USD), dtype: object\n</code></pre> <p>The same for plotting:</p> <pre><code>pf[(10, 20, 'ETH-USD')].plot().show()\n</code></pre> <p></p> <p>It's not all about backtesting - vectorbt can be used to facilitate financial data analysis and visualization.</p> <ul> <li>Let's generate a GIF that animates the %B and bandwidth of Bollinger Bands for different symbols:</li> </ul> <pre><code>symbols = [\"BTC-USD\", \"ETH-USD\", \"ADA-USD\"]\nprice = vbt.YFData.download(symbols, period='6mo', missing_index='drop').get('Close')\nbbands = vbt.BBANDS.run(price)\n\ndef plot(index, bbands):\n    bbands = bbands.loc[index]\n    fig = vbt.make_subplots(\n        rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.15,\n        subplot_titles=('%B', 'Bandwidth'))\n    fig.update_layout(template='vbt_dark', showlegend=False, width=750, height=400)\n    bbands.percent_b.vbt.ts_heatmap(\n        trace_kwargs=dict(zmin=0, zmid=0.5, zmax=1, colorscale='Spectral', colorbar=dict(\n            y=(fig.layout.yaxis.domain[0] + fig.layout.yaxis.domain[1]) / 2, len=0.5\n        )), add_trace_kwargs=dict(row=1, col=1), fig=fig)\n    bbands.bandwidth.vbt.ts_heatmap(\n        trace_kwargs=dict(colorbar=dict(\n            y=(fig.layout.yaxis2.domain[0] + fig.layout.yaxis2.domain[1]) / 2, len=0.5\n        )), add_trace_kwargs=dict(row=2, col=1), fig=fig)\n    return fig\n\nvbt.save_animation('bbands.gif', bbands.wrapper.index, plot, bbands, delta=90, step=3, fps=3)\n</code></pre> <pre><code>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 31/31 [00:21&lt;00:00,  1.21it/s]\n</code></pre> <p></p> <p>And this is just the tip of the iceberg of what's possible. Check out Resources to learn more.</p>"},{"location":"terms/","title":"Terms","text":"<p>This work is fair-code distributed under  Apache 2.0 with Commons Clause license.  The source code is open and everyone (individuals and organizations) can use it for free.  However, it is not allowed to sell products and services that are mostly just this software.</p> <p>If you have any questions about this or want to apply for a license exception,  please contact the author.</p> <p>Installing optional dependencies may be subject to a more restrictive license.</p>"},{"location":"terms/license/","title":"License","text":""},{"location":"terms/license/#commons-clause","title":"Commons Clause","text":"<p>\u201cCommons Clause\u201d License Condition v1.0</p> <p>The Software is provided to you by the Licensor under the License, as defined below, subject to the following condition.</p> <p>Without limiting other conditions in the License, the grant of rights under the License will not include, and the License does not grant to you, the right to Sell the Software.</p> <p>For purposes of the foregoing, \u201cSell\u201d means practicing any or all of the rights granted to you under the License to provide to third parties, for a fee or other consideration (including without limitation fees for hosting or consulting/ support services related to the Software), a product or service whose value derives, entirely or substantially, from the functionality of the Software. Any license notice or attribution required by the License must also include this Commons Clause License Condition notice.</p> <p>Software: vectorbt</p> <p>License: Apache 2.0 with Commons Clause</p> <p>Licensor: Oleg Polakow</p>"},{"location":"terms/license/#apache-20","title":"Apache 2.0","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright 2020 Oleg Polakow</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"}]}